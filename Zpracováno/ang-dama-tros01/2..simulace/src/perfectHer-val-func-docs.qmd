---
title: "Perfect Endgame Heuristic"
subtitle: "Anglická dáma - Obecne principy s kontextovou zavislosti"
author: "AI1 Projekt"
date: today

jupyter: julia-1.12
execute:
  eval: false
  echo: true
---

# Charakteristika

`perfect_endgame_heuristic` je **obecna principialni** heuristika postavena na 7 strategickych principech:

| # | Princip | Popis |
|---|---------|-------|
| 1 | Material | Zakladni hodnota figur a 1v1 ochrana |
| 2 | Red Position | Viditelnost pozice cerveneho |
| 3 | Coordination | Squeeze formace |
| 4 | Retreat Penalty | Pseudo-terminalni stavy |
| 5 | Net Formation | Diagonalni spread operatora |
| 6 | Mobility | Omezeni tahu soupere |
| 7 | Cornering | Tlak k okrajum |
| 8 | Corner Control | Kontextove zavisle rizeni rohu |

::: {.callout-note}
## Přechod na obecné principy
Zatímco základní heuristiky často spoléhají na materiálovou převahu, tato kapitola zavádí **obecné principy**, které umožňují AI efektivně řešit koncovky i v situacích, kdy materiál nehraje roli (např. 2v1).
:::

> **Pristup:** Zadne hardcoded pozice - pouze obecne principy.

## Silne stranky

- Obecna - funguje z libovolne startovni pozice
- Kontextove zavisle - bonus se meni podle faze hry
- Robustni vuci horizon effectu (depth 5 i 6)
- Move ordering pro lepsí pruning

## Klicova inovace

1. **Anchor vs Operator** - rozliseni roli kralu
2. **Pseudo-terminalni stavy** - penalta za zbytecny ustup
3. **Move ordering** - serazeni tahu pred minimax

\newpage

# Matematická notace

Pro formální popis heuristiky používáme následující značení:

- $P$: Množina všech kamenů na desce.
- $W \subset P$: Množina bílých kamenů (MAX hráč).
- $R \subset P$: Množina červených kamenů (MIN hráč).
- $K_W \subseteq W$: Množina bílých králů.
- $K_R \subseteq R$: Množina červených králů.
- $pos(p) = (r, c)$: Pozice kamene $p$ (řádek, sloupec).
- $d_{Cheb}(a, b) = \max(|a_r - b_r|, |a_c - b_c|)$: Chebyshevova vzdálenost (počet tahů krále).


\newpage

# Implementace - Klicove sekce

::: {.callout-note}
Vsechny ukázky kódu níže jsou **embedy** ze souboru `heuristics.jl`. 
Pri zmene zdrojoveho kodu se dokumentace automaticky aktualizuje.
:::

## Materiál a 1v1 ochrana

Skóre materiálu $S_{mat}$ je vypočteno jako rozdíl ohodnocení kamenů:

$$ S_{mat} = \sum_{w \in W} V(w) - \sum_{r \in R} V(r) $$

kde hodnota kamene $V(p)$ je definována:
$$ V(p) = \begin{cases} 100 & \text{pokud } p \text{ je král} \\ 40 & \text{pokud } p \text{ je pěšec} \end{cases} $$

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_material"}
```
1. Bílé kameny (MAX)
2. Červené kameny (MIN)

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_1v1"}
```
1. Penalta za redukci na 1v1 (nežádoucí stav v koncovce)

> **Rozdil od Optimal:** `optimal` pouziva penaltu -2000, `perfect` pouziva hard forbidden -99999.

## Pozice červeného

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_red_pos"}
```

> **Klicovy rozdil:** Pozice cerveneho je primo viditelna v hodnote - penalta I bonus.

## Koordinovaný útok (Squeeze)

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_coordination"}
```

\newpage

## Penalta za zbytečný ústup

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_retreat"}
```

> **Toto zamezuje hre na cas** - bily se nemuze utahovat do nekonecna.

## Diagonální síťová formace (Net)

Kracive logika - rozliseni **kotvy** a **operatora**:

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_net"}
```

> **Toto je klicova inovace** - jakmile kotva drzi roh, operator MUSI jit diagonalne (14→18), ne k rohu (14→10).

\newpage

## Mobilita soupeře

Čím méně tahů má červený, tím lépe. 0 tahů = výhra.

Mobilita je definována počtem legálních tahů $|M(R)|$ červeného hráče:

$$ S_{mob} = \begin{cases} 10000 & \text{pokud } |M(R)| = 0 \quad (\text{Výhra}) \\ 600 & \text{pokud } |M(R)| = 1 \\ 300 & \text{pokud } |M(R)| = 2 \\ 100 & \text{pokud } |M(R)| = 3 \\ 0 & \text{jinak} \end{cases} $$

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_mobility"}
```
1. Bonus za úplné zablokování soupeře (Výhra)
2. Bonus za omezení na 1 tah
3. Bonus za omezení na 2 tahy
4. Bonus za omezení na 3 tahy

## Cornering (Tlak k okrajům)

Tlačení červeného k okrajům desky ("Kontrola hry").

Cílem je vytlačit červeného z centra (4.5, 4.5) směrem k okrajům. Používáme Chebyshevovu vzdálenost:

$$ d_{center}(r) = \max(|r_{row} - 4.5|, |r_{col} - 4.5|) $$

Celkové skóre za cornering:
$$ S_{corn} = \sum_{r \in R} (d_{center}(r) \times 40) + B_{edge}(r) $$

kde $B_{edge}(r) = 150$ pokud $r$ leží přímo na okraji desky.

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_cornering"}
```
1. Chebyshevova vzdálenost od středu (tlačení k okrajům)
2. Bonus za dosažení první/poslední řady
3. Bonus za dosažení krajního sloupce

## Kontextově závislé řízení rohu

Tento princip řídí spolupráci dvou bílých králů ($w_1, w_2$) při chytání červeného ($r$) do sítě u rohu (pole 1).

Definujeme **kotvu** ($w_{anchor}$) jako krále bližšího k rohu:
$$ w_{anchor} = \arg\min_{w \in \{w_1, w_2\}} d_{Cheb}(w, \text{Corner}_1) $$

Druhý král je **operátor** ($w_{op}$). Skóre sítě $S_{net}$ je uděleno, pokud operátor drží diagonálu:
$$ S_{net} = \begin{cases} 1200 & \text{pokud } w_{op} \text{ je na diagonále } \wedge d_{Cheb}(w_{op}, \text{Corner}_1) \ge 3 \\ -800 & \text{pokud } d_{Cheb}(w_{op}, \text{Corner}_1) \le 2 \quad (\text{Crowding}) \end{cases} $$


```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/heuristics.jl" region="perfect_corner_control"}
```
1. Nalezení "kotvy" (král nejblíže rohu 5)
2. Squeeze bonus (operátor na diagonále)
3. Optimální vzdálenost operátora (4 pole)
4. Maximální rozestup pro "síť" (5+ polí)

> **Kontextova zavislost** - bonus za roh POUZE kdyz tam jeste nikdo neni.

\newpage

# Move Ordering

Kricka optimalizace pro reseni horizon effectu:

```{.julia include="/home/sim/Obsi/Prods/04-škola/Předměty/mgr3/4IZ431..AI1/Zpracováno/ang-dama-tros01/2..simulace/src/testvaluefunc.jl" region="move_ordering"}
```

**Vyhody:**

1. **Lepsi alpha-beta pruning** - nejlepsi tahy prvni
2. **Tiebreaking** - pri rovnosti vyhrava vyssi okamzita heuristika

\newpage

# Validace

```{julia}
#| label: load-simulation-data
#| eval: true
#| echo: false
#| output: asis

# ── Nalezeni posledniho simulation runu ──────────────────────────────
cur_doc_dir = pwd()  # Quarto nastavi CWD na adresar dokumentu
sim_base_path = joinpath(cur_doc_dir, "..", "out", "simulation_outputs")
run_dirs = filter(d -> startswith(d, "run_"), readdir(sim_base_path))
latest_run = sort(run_dirs)[end]
active_run_path = joinpath(sim_base_path, latest_run)
println("**Zdrojovy run:** `$latest_run`\n")

# ── Parsovani pruběh_simulace.txt ────────────────────────────────────
raw = read(joinpath(active_run_path, "pruběh_simulace.txt"), String)
lines = split(raw, "\n")

# Extrakce zadani
for l in lines
    m_white = match(r"Bílý: (\d+) krákov?.* na pozicích ([\d, ]+)", l)
    m_red = match(r"Červený: (\d+) krákov?.* na pozici (\d+)", l)
    m_depth = match(r"Hloubka prohledávání: (\d+)", l)
    if m_white !== nothing
        println("- **Bily:** $(m_white[1]) kralove na pozicich $(m_white[2])")
    elseif m_red !== nothing
        println("- **Cerveny:** $(m_red[1]) kral na pozici $(m_red[2])")
    elseif m_depth !== nothing
        println("- **Hloubka:** $(m_depth[1])")
    end
end

# ── Extrakce dat jednotlivych tahu ───────────────────────────────────
struct MoveData
    num::Int
    player::String  # "Bily" / "Cerveny"
    role::String    # "MAX" / "MIN"
    move::String
    score::Float64
    nodes::Int
    position::String
    eval_score::Int
end

global moves = MoveData[]
move_counter = 0
i = 1
while i <= length(lines)
    l = lines[i]
    # Match "Tah X.Y: ... BÍLÝ (MAX)" nebo "ČERVENÝ (MIN)"
    m_tah = match(r"Tah \d+\.\d+: .*(BÍLÝ|ČERVENÝ).*\((MAX|MIN)\)", l)
    if m_tah !== nothing
        move_counter += 1
        player = m_tah[1] == "BÍLÝ" ? "Bily" : "Cerveny"
        role = m_tah[2]
        # Dalsi radky: tah, skore, uzly
        m_move = match(r"Nejlepší tah: (.+)", lines[i+1])
        m_score = match(r"Očekávané skóre: ([\d.-]+)", lines[i+2]) # Upraveno pro minus minus
        m_nodes = match(r"Počet uzlů ve stromu: (\d+)", lines[i+3])

        if m_move !== nothing && m_score !== nothing && m_nodes !== nothing
            # Hledame "Po tahu" blok
            j = i + 4
            pos_str = ""
            eval_val = 0
            while j <= length(lines)
                m_pos = match(r"Pozice: (.+)", lines[j])
                m_eval = match(r"Hodnocení: (-?\d+)", lines[j]) # Upraveno pro minus
                if m_pos !== nothing
                    pos_str = strip(m_pos[1])
                end
                if m_eval !== nothing
                    eval_val = parse(Int, m_eval[1])
                    break
                end
                if startswith(strip(lines[j]), "─")
                    break
                end
                j += 1
            end
            push!(moves, MoveData(
                move_counter, player, role,
                strip(m_move[1]),
                parse(Float64, m_score[1]),
                parse(Int, m_nodes[1]),
                pos_str, eval_val
            ))
            i = j + 1
        else
            i += 1
        end
    else
        i += 1
    end
end

# ── Detekce vysledku ─────────────────────────────────────────────────
result_line = findfirst(l -> occursin("VYHRÁL", l), lines)
global result_str = result_line !== nothing ? strip(lines[result_line]) : "Hra neskoncila"

println("\n## Vysledky prohledavani — prehled po tazich\n")
println("| # | Hrac | Tah | Skore | Uzlu | Pozice po tahu | Hodnoceni |")
println("|--:|------|-----|------:|-----:|----------------|----------:|")
for m in moves
    score_str = m.score >= 10000 ? "**$(Int(m.score))**" : string(Int(m.score))
    println("| $(m.num) | $(m.player) ($(m.role)) | $(m.move) | $score_str | $(m.nodes) | $(m.position) | $(m.eval_score) |")
end

println("\n> $result_str")
```

\newpage


### Vysvětlivky k reportu

- **NO MOVES**: Pokud se ve stromu objeví uzel označený jako `[NO MOVES]`, znamená to, že hráč na tahu nemá k dispozici žádný legální tah. V dámě to znamená okamžitou prohru.
    - Pokud nemůže táhnout MAX (Bílý), skóre je $-\infty$.
    - Pokud nemůže táhnout MIN (Červený), skóre je $+\infty$ (z pohledu MAX hráče je to výhra).
- **OŘEZÁNO (Cut-off)**: Větve označené šedě a přerušovanou čarou nebyly prohledány, protože algoritmus matematicky dokázal, že nemohou ovlivnit výsledek (buď jsou pro soupeře příliš dobré, takže je hráč nevybere, nebo naopak).

\newpage

## Souhrnná statistika (Standardní hra)

Následující statistiky vycházejí ze stejné **standardní hry** jako benchmark výše (W@10,14 vs R@1). 
Tato sekce detailněji analyzuje průběh celé simulace.

```{julia}
#| label: summary-stats
#| eval: true
#| echo: false
#| output: asis

# ── Vypocet statistik z nactenych dat ────────────────────────────────
white_moves = filter(m -> m.player == "Bily", moves)
red_moves = filter(m -> m.player == "Cerveny", moves)

avg_white = length(white_moves) > 0 ? round(Int, sum(m.nodes for m in white_moves) / length(white_moves)) : 0
avg_red = length(red_moves) > 0 ? round(Int, sum(m.nodes for m in red_moves) / length(red_moves)) : 0

# Zlomovy tah: kde skore poprve >= 10000
breakthrough = findfirst(m -> m.score >= 10000, moves)
bt_str = breakthrough !== nothing ? "#$(moves[breakthrough].num) ($(moves[breakthrough].move), skore $(Int(moves[breakthrough].score)))" : "nenalezen"

# Terminalni nalezeni: kde skore >= 99999
terminal = findfirst(m -> m.score >= 99999, moves)
term_str = terminal !== nothing ? "od tahu #$(moves[terminal].num)" : "nenalezeno"

println("| Metrika | Hodnota |")
println("|---------|---------|")
println("| **Celkovy pocet tahu** | $(length(moves)) |")
println("| **Prumerne uzly/tah (bily)** | $avg_white |")
println("| **Prumerne uzly/tah (cerveny)** | $avg_red |")
println("| **Zlomovy tah** | $bt_str |")
println("| **Terminalni nalezeni** | $term_str |")

println("\n### Vysvětlení pojmů")
println("- **Zlomový tah**: Tah, kdy algoritmus poprvé detekuje vyhranou pozici (skóre >= 10000).")
println("- **Terminalni nalezeni**: Tah, kdy algoritmus najde nejrychlejší cestu k vítězství nebo matu.")

println("\n> **Efektivita orezavani:** Cerveny ma mensi stromy (prumerne $avg_red vs $avg_white uzlu) — bily ma vetsi volnost a vice alternativ.")
```

\newpage

# Zaver

`perfect_endgame_heuristic` predstavuje **druhou iteraci** heuristiky, ktera resi vsechny problemy `optimal_endgame_heuristic`:

| Problem | Optimal | Perfect |
|---------|---------|---------|
| Hardcoded pozice | Ano | Ne |
| Horizon effect | Nere | Reseno |
| Crowding | Muze nastat | Penalizovano |
| Kontextova zavislost | Chybi | Implementovano |
| 1v1 ochrana | Penalta | Forbidden |
| Move ordering | Chybi | Implementovano |

Pro produkcni nasazeni je `perfect_endgame_heuristic` doporucena volba.

\newpage

\newpage

# Optimalizace pro hloubku 6 a řešení regresí

```{julia}
#| label: verify-regression
#| eval: true
#| echo: true
#| output: asis

# Load log file
log_path = joinpath(cur_doc_dir, "..", "out", "verification", "verification_log.txt")

if isfile(log_path)
    lines = readlines(log_path)

    # ── Parsování logu ───────────────────────────────────────────────────
    struct VerifMove
        turn::Int
        player::String
        move::String
        score::Float64
    end

    verif_moves = VerifMove[]
    for l in lines
        # Regex: Turn 1 White: 14-9 (Score: 1770.0)
        m = match(r"Turn (\d+) (White|Red):\s+([0-9x-]+) \(Score: ([0-9.-]+)\)", l)
        if m !== nothing
            push!(verif_moves, VerifMove(
                parse(Int, m[1]),
                m[2],
                m[3],
                parse(Float64, m[4])
            ))
        end
    end

    # ── Výpis výsledků ───────────────────────────────────────────────────
    println("## Verifikace optimální sekvence (Depth 6)\n")
    println("| Tah | Hráč | Tah | Skóre |")
    println("|----:|:-----|:----|------:|")

    has_14_18 = false

    for vm in verif_moves
        highlight = ""
        # Kritický tah: 14-18
        if vm.move == "14-18" && vm.player == "White"
            highlight = "**"
            has_14_18 = true
        end

        score_fmt = vm.score >= 9999 ? "WIN" : string(round(vm.score, digits=1))

        println("| $(vm.turn) | $(vm.player) | $(highlight)$(vm.move)$(highlight) | $score_fmt |")
    end

    result_line = findfirst(l -> occursin("Wins", l), lines)
    final_result = result_line !== nothing ? lines[result_line] : "Unknown"

    println("\n> **Výsledek:** Sekvence obsahuje kritický tah `14-18`: $(has_14_18 ? "**ANO**" : "NE"). Konečný stav: **$final_result**.")
else
    println("> *Log verifikace nenalezen. Spusťte `verify_sequence.jl`.*")
end
```

# Final Verification Report

## Regression Analysis: Tie-Breaking at Depth 6

During the optimization process, a critical issue was identified where the heuristic assigned equal scores to the optimal move `14-9` and the suboptimal move `10-7`. This was caused by two factors:

1. > **Metrika vzdálenosti:** Zde se klíčově uplatňuje **Čebyševova vzdálenost** (max(|dx|, |dy|)), která správně měří vzdálenost v počtu tahů krále (včetně diagonálního pohybu), na rozdíl od klasických pravoúhlých metrik.
2.  **Crowding Penalty**: The heuristic penalized the optimal `14-9` line because both kings entered the "Near Corner" zone simultaneously, triggering a "Crowding" penalty intended for static phases.

### Applied Fixes

1.  **Chebyshevova vzdálenost**: Tato metrika správně vyhodnocuje Square 5 jako Distance 1 (1 krok), zatímco Square 9 a Square 2 jsou vzdáleny 2 kroky.
2.  **Targeted Proximity Bonus**: Added a specific bonus (+500) for reaching Distance 1 (`closer_dist <= 1`). Since only the optimal line `14-9 -> 9-5` reaches Distance 1 within the search horizon, this creates a decisive score gradient.
3.  **Relaxed Crowding Check**: Adjusted the crowding penalty to only trigger when *both* kings are at distance <= 2, preventing false positives during the necessary approach phase.

### Verification Result

The final verification run confirms the fix:

- **Optimal Move (14-9)**: Score **4160.0** (Distance 1 Bonus active)
- **Suboptimal Move (10-7)**: Score **3670.0** (Distance 2, no Bonus)
- **Score Differential**: **+490.0** favoring the optimal move.

The simulation now correctly plays out the full winning sequence: `14-9` -> `1-5` -> `10-14` -> `5-1` -> `9-5` -> `1-6` -> `5-1` -> `6-2` -> `14-18` (Winning Position).



