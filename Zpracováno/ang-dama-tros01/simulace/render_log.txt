
Starting julia-1.12 kernel...Done

Executing 'perfectHer-val-func-docs.quarto_ipynb'
  Cell 1/4: 'load-simulation-data'.....Done
  Cell 2/4: 'render-trees'.............Done
  Cell 3/4: 'brute-force-validation'...

An error occurred while executing the following cell:
------------------

# Naƒçten√≠ hern√≠ logiky (pokud je≈°tƒõ nen√≠)
# P≈ôedpokl√°d√°me, ≈æe jsme v adres√°≈ôi 'Zpracov√°no/ang-dama-value-func'
include(joinpath(cur_doc_dir, "boards.jl"))
include(joinpath(cur_doc_dir, "heuristics.jl"))
# testvaluefunc obsahuje minimax_with_tree, mus√≠me ho naƒç√≠st
# Pozor: testvaluefunc m≈Ø≈æe spou≈°tƒõt vƒõci v main scope, ale je to struct/funkce def
include(joinpath(cur_doc_dir, "testvaluefunc.jl"))

# Definice Minimaxu BEZ o≈ôez√°v√°n√≠ (pro srovn√°n√≠)
function minimax_no_pruning(board::Matrix{Int}, depth::Int, is_maximizing::Bool)
    if depth == 0
        return Float64(perfect_endgame_heuristic(board)), nothing, 1
    end

    player = is_maximizing ? 1 : -1
    moves = get_legal_moves(board, player)

    if isempty(moves)
        return is_maximizing ? -99999.0 : 99999.0, nothing, 1
    end

    best_move = moves[1]
    total_nodes = 1
    
    if is_maximizing
        max_eval = -Inf
        for move in moves
            new_board = make_move(board, move)
            score, _, nodes = minimax_no_pruning(new_board, depth - 1, false)
            total_nodes += nodes
            if score > max_eval
                max_eval = score
                best_move = move
            end
        end
        return max_eval, best_move, total_nodes
    else
        min_eval = Inf
        for move in moves
            new_board = make_move(board, move)
            score, _, nodes = minimax_no_pruning(new_board, depth - 1, true)
            total_nodes += nodes
            if score < min_eval
                min_eval = score
                best_move = move
            end
        end
        return min_eval, best_move, total_nodes
    end
end

# Wrapper pro Alpha-Beta (aby vracel poƒçet uzl≈Ø podobnƒõ)
# minimax_with_tree vrac√≠ (score, best_move, node_id). 
# Poƒçet uzl≈Ø zjist√≠me z glob√°ln√≠ promƒõnn√© tree_nodes, pokud resetujeme strom.
function run_alphabeta_stats(board, depth, is_max)
    global tree_nodes = TreeNodeAB[] # Reset glob√°ln√≠ struktury z testvaluefunc.jl
    global tree_enabled = true
    
    score, move, _ = minimax_with_tree(board, depth, -Inf, Inf, is_max, 0, "ROOT")
    
    return score, move, length(tree_nodes)
end

# ‚îÄ‚îÄ Testovac√≠ sc√©n√°≈ô ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Nastav√≠me zaj√≠mavou pozici (nap≈ô. 6 vs 2, kde je dost tah≈Ø)
# B√≠l√Ω na 14, 18. ƒåerven√Ω na 5 (kr√°l).
# B√≠l√Ω na tahu.
test_board = zeros(Int, 8, 8)
test_board[4, 2] = 2  # B√≠l√Ω kr√°l na 14
test_board[5, 2] = 2  # B√≠l√Ω kr√°l na 18
test_board[2, 3] = -2 # ƒåerven√Ω kr√°l na 7
test_board[3, 8] = 2  # Dal≈°√≠ b√≠l√Ω
test_depth = 4       # Hloubka 4 (dostateƒçn√° pro rozd√≠l, ale rychl√°)

# ‚îÄ‚îÄ Spu≈°tƒõn√≠ algoritm≈Ø ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
val_bf, move_bf, nodes_bf = minimax_no_pruning(test_board, test_depth, true)
val_ab, move_ab, nodes_ab = run_alphabeta_stats(test_board, test_depth, true)

# ‚îÄ‚îÄ V√Ωpis v√Ωsledk≈Ø ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
println("| Algoritmus | Skore | Nejlepsi tah | Pocet uzlu | Uspora |")
println("|------------|------:|-------------:|-----------:|-------:|")

move_bf_str = move_bf !== nothing ? format_move(move_bf) : "None"
move_ab_str = move_ab !== nothing ? format_move(move_ab) : "None"

# V√Ωpoƒçet √∫spory
savings = round(100 * (1 - nodes_ab/nodes_bf), digits=1)

println("| Brute Force (Minimax) | $val_bf | $move_bf_str | $nodes_bf | 0% |")
println("| Alpha-Beta Pruning | $val_ab | $move_ab_str | $nodes_ab | **$savings%** |")

if val_bf == val_ab && move_bf_str == move_ab_str
    println("\n> **VERDIKT:** ‚úÖ Algoritmy vr√°tily shodn√Ω v√Ωsledek. Alpha-Beta o≈ôez√°v√°n√≠ je korektn√≠.")
else
    println("\n> **VERDIKT:** ‚ùå V√Ωsledky se li≈°√≠! Alpha-Beta implementace m≈Ø≈æe b√Ωt chybn√°.")
end
------------------

----- stdout -----
Starting restored file exec...
----- stderr -----
WARNING: Detected access to binding `Main.run_alphabeta_stats` in a world prior to its definition world.
  Julia 1.12 has introduced more strict world age semantics for global bindings.
  !!! This code may malfunction under Revise.
  !!! This code will error in future versions of Julia.
Hint: Add an appropriate `invokelatest` around the access to this binding.
To make this warning an error, and hence obtain a stack trace, use `julia --depwarn=error`.
------------------

UndefVarError: `TreeNodeAB` not defined in `Main`
Suggestion: check for spelling errors or missing imports.

Stacktrace:
 [1] [0m[1mrun_alphabeta_stats[22m[0m[1m([22m[90mboard[39m::[0mMatrix[90m{Int64}[39m, [90mdepth[39m::[0mInt64, [90mis_max[39m::[0mBool[0m[1m)[22m
[90m   @[39m [35mMain[39m [90m./[39m[90m[4mIn[3]:57[24m[39m
 [2] top-level scope
[90m   @[39m [90m[4mIn[3]:78[24m[39m
 [3] [0m[1meval[22m[0m[1m([22m[90mm[39m::[0mModule, [90me[39m::[0mAny[0m[1m)[22m
[90m   @[39m [90mCore[39m [90m./[39m[90m[4mboot.jl:489[24m[39m

[33mWARN: Error encountered when rendering files[39m
